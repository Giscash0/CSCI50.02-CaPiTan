*******************************************************************************
* LAB #4
* - Carlos, Danny II
* - Piscasio, Johannes
* - Tan, Jacob
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* Full Adder
*
* Truth Table:
* a b c_in sum c_out
* 0 0  0    0    0
* 0 0  1    1    0
* 0 1  0    1    0
* 0 1  1    0    1
* 1 0  0    1    0
* 1 0  1    0    1
* 1 1  0    0    1
* 1 1  1    1    1
*
* sum = !a!bc_in + !ab!c_in + a!b!c_in + abc_in   from the truth table
*     = c_in(!a!b + ab) + !c_in(!ab + a!b)        by distributive law
*     = c_in!(a⊕b) + !c_in(a⊕b)                 substituting to XOR
*     = a ⊕ b ⊕ c_in                            substituting to XOR
* c_out = !abc_in + a!bc_in + ab!c_in + abc_in    from the truth table
*       = c_in(!ab + a!b) + ab(!c_in + c_in)      by distributive law
*       = c_in(!ab + a!b) + ab(1)                 by complement law
*       = c_in(!ab + a!b) + ab                    by identity law
*       = ab + c_in(a⊕b)                         turn to xor because we already
*                                                 know a⊕b from the sum
*       = !(!(ab + c_in(a⊕b)))                   by double negation law
*       = !(!(ab)!(c_in(a⊕b)))                   by De Morgan's theorem
*******************************************************************************
.subckt fa a b c_in sum c_out
  Xsum1 a b out1 xor2
	Xsum2 out1 c_in sum xor2
	Xcarry1 a b out2 nand2
	Xcarry2 c_in out1 out3 nand2
	Xcarry3 out2 out3 c_out nand2
.ends

*******************************************************************************
* 32-bit Full Adder
* We instantiate 32 full adder and the carry ripples from the less significant
* bit to the more significant bit. The ith full adder adds a_i and b_i with the
* carry input being the carry output of the previous full adder, which is
* c_out_i-1. Since the 0th fa doesn't have a previous fa, its carry input is
* cin0. Thus, each bit instantiation goes like:
*      Xbit#0 a31 b31 cout30 sum31 cout31 fa
*      Xbit#1 a30 b30 cout29 sum30 cout30 fa
*      ...
*      Xbit#30 a1 b1 cout0 sum1 cout1 fa
*      Xbit#31 a0 b0 cin0 sum0 cout0 fa
*
* However with the power of jsim, we can instantiate by:
*      Xbits 32_a 32_b 31_prev_cout_then_least_bit's_cin 32_sum 32_carry_out fa
*******************************************************************************
.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xbits a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends

*******************************************************************************
* 32-bit Counter
* The counter inputs a reset that turns all bits to 0 when its 1 and the 32-bit
* to be added a[31:0]. The output would be the current count f[31:0]. We have
* 3 main elements: the adder, the reseter, and the memory.
*
* In instantiating the adder, we add the 32-bit input and the 32-bit memory and
* output the 32-bit sum. We don't care about the last 2 cout but we have to put
* it because that is how our 32-bit full adder is instantiated.
*
* In instantiating the reseter, we use 2-way multiplexers. All multiplexers'
* s node is connected to the reset input node of the counter. All multiplexers'
* d1 node is connected to the ground or 0. The d0 nodes depend on the sum output
* from the adder. When reset is 0, the reseter outputs the sum otherwise the
* reseter outputs 0. Hence, instantiating goes like:
*      Xmux#0 reset sum31 0 mux_out31 mux2
*      Xmux#1 reset sum30 0 mux_out30 mux2
*      ...
*      Xmux#31 reset sum0 0 mux_out0 mux2
*    OR
*      Xmux reset reset (reset x30) sum[31:0] 0 0 (0 x30) mux_out[31:0] mux2
*
* In instantiating the memory, we use 32 d flip-flops. The next state is the
* output from the reseter mux_out[31:0]. All of the clocks are connected to the
* input clk of the counter so that the memory would simultaneously go to the
* next state. The current state f[31:0] is the current count which is to be added
* to the adder. Instantiating goes like:
*      Xdrg#0 mux_out31 clk f31 dreg
*      Xdrg#1 mux_out30 clk f30 dreg
*      ...
*      Xdrg#1 mux_out0 clk f0 dreg
*    OR
*      Xdrg mux_out[31:0] clk clk (clk x30) f[31:0] dreg
*******************************************************************************
.subckt counter32 reset a[31:0] f[31:0] clk
  Xadd a[31:0] f[31:0] 0 sum[31:0] cout[31:30] add32
  Xmux reset#32 sum[31:0] 0#32 mux_out[31:0] mux2
  Xdrg mux_out[31:0] clk#32 f[31:0] dreg
.ends

*******************************************************************************
* Pitfall: DON'T use numbers AND iterators in your node names at the same time,
*          e.g., temp[31:0] and temp2[31:0] will result in conflicts!
*
* Also, you may need to use these statements when making your own counter32:
*
* .connect node othernode(s)...
*  = connects the first node to all the subsequent nodes
*    - For example, ".connect a b[31:0]" connects a to b31, b30, ..., b0.
*    - You can also connect nodes directly to ground ("false") by saying
*      ".connect 0 othernode(s)..."
*    - You can also connect nodes directly to vdd ("true") by saying
*      ".connect vdd othernode(s)..."
*
* Xid s d0 d1 z mux2
*  = "mux2" defines a 2-way multiplexer circuit.
*    - If s = 0, node z is set to the value of node d0.
*    - If s = 1, node z is set to the value of node d1.
*    - s, d0, d1 and z are SINGLE BITS. As usual, use iterators to create
*      several multiplexers at once.
*    - Note that the reset node of your counter32 is only a single bit
*      (NOT 32 bits), so to use it with multiple multiplexers, use the form
*      "node#n" to make n copies of the node, e.g., "reset#32".
*
* Xid d clk q dreg
*  = "dreg" defines a flip-flop register q (a single bit of "memory") and sets
*    it to the value of another node, d.
*    - Unlike "connect"-ing nodes, the value only gets stored into q when clk
*      is doing a rising transition (also known as a "positive edge trigger").
*    - Hint: You will also need iteration for this since we need a 32-bit
*      register, which means you will also need to make 32 copies of clk.
*******************************************************************************

*******************************************************************************
* Finally, it's time to simulate.
* This circuit block instantiates the counter32 circuit that you just wrote.
* We pass it a single-bit reset signal, a 32-bit increment value, a 32-bit
* register, and a clock signal (we just used the JSim-predefined clk1).
*******************************************************************************
Xcounter32 reset incr[31:0] reg[31:0] clk1 counter32

*******************************************************************************
* This "reset" waveform sets up a reset signal that has a delayed start of 15ns
* and then goes to the next value every 50ns.
* The values "1 0 0 0 1 0" indicate that the reset signal only turns on twice
* (at times 15ns and 215ns) for a period of 50ns intervals each, and the signal
* is turned off otherwise.
*******************************************************************************
Wreset reset nrz(0, 5, 50ns, 15ns, 0.001ns, 0.001ns)
+ 1 0 0 0 1 0

*******************************************************************************
* This "incr" waveform sets up a increment value for your counter32 circuit.
* Note that it does NOT have a delayed start. The values "0 1 3 -1" roughly
* translate to the following "commands" in Java-like syntax:
*   reg += 0;  //  0 means don't touch the value
*   reg++;     //  1 means increment by 1
*   reg += 3;  //  3 means increment by 3
*   reg--;     // -1 means decrement by 1
* But note that these "commands" will happen EVERY positive clock edge (and
* only when your reset signal is off)!
*******************************************************************************
Wincr incr[31:0] nrz(0, 5, 50ns, 0ns, 0.001ns, 0.001ns)
+ 0 1 3 -1

*******************************************************************************
* Plot our reset waveform, our incr waveform, clk1, and your 32-bit register.
* Note: sd() displays a range of nodes as a signed decimal (instead of hex)
*******************************************************************************
.tran 300ns
.plot reset
.plot sd(incr[31:0])
.plot clk1
.plot sd(reg[31:0])

*******************************************************************************
* Increasing:   reg increases by incr on each rising edge of clk.wdaw
* Decrementing: reg decreases on each clk if incr is negative (two’s complement).
* Resetting:    reg loads 0 at the next rising clk if reset=1.
*
* When reset or incr changes, reg does not update immediately, causing delay.
* The new value only appears after the next rising clk edge, and after the
* propagation delay through the adder, mux, and register clock-to-Q delay.
*
* (b) Why not just a super-fast clock?
* The speed of the clock does not eliminate the inherent delays in the circuit. 
* Each clock cycle still has to accommodate the propagation delays of
* the adder, the mux, and the setup/hold requirements of the registers. 
* Thus, the clock period necessarily must be longer than the critical path delay.
* 
* If the sum of delays is greater than the clock period, the next 
* rising edge will arrive before the outputs have stabilized.
* This causes incorrect values to be latched and setup/hold time violations.
*******************************************************************************
