*******************************************************************************
* LAB #5
* - Carlos, Danny II
* - Piscasio, Johannes
* - Tan, Jacob
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* Full Adder
*
* Truth Table:
* a b c_in sum c_out
* 0 0  0    0    0
* 0 0  1    1    0
* 0 1  0    1    0
* 0 1  1    0    1
* 1 0  0    1    0
* 1 0  1    0    1
* 1 1  0    0    1
* 1 1  1    1    1
*
* sum = !a!bc_in + !ab!c_in + a!b!c_in + abc_in   from the truth table
*     = c_in(!a!b + ab) + !c_in(!ab + a!b)        by distributive law
*     = c_in!(a⊕b) + !c_in(a⊕b)                 substituting to XOR
*     = a ⊕ b ⊕ c_in                            substituting to XOR
* c_out = !abc_in + a!bc_in + ab!c_in + abc_in    from the truth table
*       = c_in(!ab + a!b) + ab(!c_in + c_in)      by distributive law
*       = c_in(!ab + a!b) + ab(1)                 by complement law
*       = c_in(!ab + a!b) + ab                    by identity law
*       = ab + c_in(a⊕b)                         turn to xor because we already
*                                                 know a⊕b from the sum
*       = !(!(ab + c_in(a⊕b)))                   by double negation law
*       = !(!(ab)!(c_in(a⊕b)))                   by De Morgan's theorem
*******************************************************************************
.subckt fa a b c_in sum c_out
  Xsum1 a b out1 xor2
	Xsum2 out1 c_in sum xor2
	Xcarry1 a b out2 nand2
	Xcarry2 c_in out1 out3 nand2
	Xcarry3 out2 out3 c_out nand2
.ends

*******************************************************************************
* 32-bit Full Adder
* We instantiate 32 full adder and the carry ripples from the less significant
* bit to the more significant bit. The ith full adder adds a_i and b_i with the
* carry input being the carry output of the previous full adder, which is
* c_out_i-1. Since the 0th fa doesn't have a previous fa, its carry input is
* cin0. Thus, each bit instantiation goes like:
*      Xbit#0 a31 b31 cout30 sum31 cout31 fa
*      Xbit#1 a30 b30 cout29 sum30 cout30 fa
*      ...
*      Xbit#30 a1 b1 cout0 sum1 cout1 fa
*      Xbit#31 a0 b0 cin0 sum0 cout0 fa
*
* However with the power of jsim, we can instantiate by:
*      Xbits 32_a 32_b 31_prev_cout_then_least_bit's_cin 32_sum 32_carry_out fa
*******************************************************************************
.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xbits a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends

*******************************************************************************
* 32-bit Adder/Subtractor
* For inputs, we have a 32-bit A and B as well as the op0. The input op0 is 0
* for addition and 1 for subtraction. We know that A - B = A + ~B + 1. We also
* know that the constructor for the 32-bit Full Adder inputs a carry in bit for
* the least significant bit. Thus, we can connect op0 to cin0 to handle the +1.
*
* For the ~B, we can just use a 2-input multiplexer where d0 = B, d1 = ~B, and
* s = op0. This is so that when op0 = 0, indicating addition, what is being added
* is just A + B(d0) + 0(op0) or A + B. Otherwise, when op0 = 1, indicating
* subtraction, what is being added is A + ~B(d1) + 1(op0) or A - B.
*
* We have output n which is 0 if fas is positive and 1 if negative. We only need
* to check fas31. The most significant bit of signed bits is 0 when it is positive
* and 1 when it is negative. Therefore, n = fas31.
* 
* Output v is 1 when the operation result in a signed overflow or the value
* "wrapped around". We notice that when the carry out of the 2 most significant
* bits are not equal, there is an overflow. If they are equal, there is no
* overflow. Putting that in a truth table, it is an exclusive or. Therefore,
* v = cout31 ⊕ cout30
*
* Output z is 1 if all 32 bits fas[31:0] are 0, otherwise z is 0.
* Suppose we want to make 2 bits return 1 if both bits are 0:
*      X = !A!B
*      X = !(A+B)
* 4 bits would be X(A,B) and X(C,D):
*      X = !(A+B)!(C+D)
*      X = !!(!(A+B)!(C+D))
* 8 bits would be X(A,B,C,D) and X(E,F,G,H):
*      X = !!(!(A+B)!(C+D)) !!(!(E+F)!(G+H))
*      X = !(!(!(A+B)!(C+D))+!(!(E+F)!(G+H)))
* 16 bits would be X(A,B,C,D,E,F,G,H) and X(I,J,K,L,M,N,O,P)
*      X = !(!(!(A+B)!(C+D))+!(!(E+F)!(G+H))) !(!(!(I+J)!(K+L))+!(!(M+N)!(O+P)))
*      X = !!(!(!(!(A+B)!(C+D))+!(!(E+F)!(G+H))) !(!(!(I+J)!(K+L))+!(!(M+N)!(O+P))))
* 32 bits would be X(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) and X(16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
*      X = !!(!(!(!(0+1)!(2+3))+!(!(4+5)!(6+7))) !(!(!(8+9)!(10+11))+!(!(12+13)!(14+15))))
*          !!(!(!(!(16+17)!(18+19))+!(!(20+21)!(22+23))) !(!(!(24+25)!(26+27))+!(!(28+29)!(30+31))))
*      X = !(
*          !(!(!(!(0+1)!(2+3))+!(!(4+5)!(6+7))) !(!(!(8+9)!(10+11))+!(!(12+13)!(14+15))))
*          +
*          !(!(!(!(16+17)!(18+19))+!(!(20+21)!(22+23))) !(!(!(24+25)!(26+27))+!(!(28+29)!(30+31))))
*          )
* This makes 16 NOR gates at the innermost, then 8 NAND gates, then 4 NOR gates,
* then 2 NAND gates, and finally a NOR gates. We arived to our answer using
* multiple De Morgan's and double negation. We substitute X to z and the numbers
* to fas[31:0].
*******************************************************************************
.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
  * nb# = ~b#
  XinvertedB b[31:0] nb[31:0] inverter
  * connect op0 to all mux
  * if op0 = 0, newb# = b#
  * else if op0 = 1, newb# = nb#
  Xbmux op0#32 b[31:0] nb[31:0] newb[31:0] mux2
  * we add a[31:0] and newb[31:0] using the 32-bit Adder with op0 as cin0
  Xas a[31:0] newb[31:0] op0 fas[31:0] cout[31:30] add32
  * since n = fas31, we connect them
  .connect fas31 n
  * we get XOR of cout31 and cout30 to get v
  Xoverflow cout[31:30] v xor2

  * in solving for z we start with the first 16 NORs
  Xza fas[31:0] fza[15:0] nor2
  * then 8 NANDs
  Xzb fza[15:0] fzb[7:0] nand2
  * then 4 NORs
  Xzc fzb[7:0] fzc[3:0] nor2
  * then 2 NANDs
  Xzd fzc[3:0] fzd[1:0] nand2
  * finally 1 NOR
  Xze fzd[1:0] z nor2
.ends

*******************************************************************************
* 32-bit Comparator
* We compare a[31:0] and b[31:0]. We have n, v, z inputs coming from the output
* of as32. op[2:1] determines the comparison type. fcmp0 is the boolean that
* affirms if the comparison is true(1) or false(0).
* We don't care when we are adding and when both op1 & op2 are 0.
*
* If op1=1 then fcmp0=1 iff A=B.
* We only care about subtraction. When subtracting using as32 and A = B,
* A - B = 0. This makes z = 1. Thus, if op1=1 then fcmp0=1 iff z=1. Therefore:
*      fcmp0 = (op1)(z)
*
* If op2=1 then fcmp0=1 iff A<B.
* We only care about subtraction. Note the following 4-bit subtraction and the
* resulting n and v values and wether A is less than B:
*      0101 - 0011: n=0 v=0 isless=0
*      1001 - 0011: n=0 v=1 isless=1
*      0011 - 0101: n=1 v=0 isless=1
*      0111 - 1101: n=1 v=1 isless=0
* We notice that isless = n⊕v. Therefore:
*      fcmp0 = (op2)(n⊕v)
*
* If both op1 and op2 are 1, then fcmp0=1 iff A<=B. This is read as less than
* OR equal to. Therefore we add the first 2:
*      fcmp0 = (op1)(z) + (op2)(n⊕v)
*******************************************************************************
.subckt cmp32 n v z op[2:1] fcmp[31:0]
  * we don't care about fcmp[31:1] so we connect it to ground
  .connect 0 fcmp[31:1]

  * for op1=1
  Xandop1 op1 z isequal and2
  
  * for op2=1
  Xxorop2 n v exclusive xor2
  Xandop2 op2 exclusive isless and2

  * for op1=op2=1
  Xboth isequal isless fcmp0 or2
.ends

* instantiating as32 and cmp32
Xas32 a[31:0] b[31:0] op0 fas[31:0] n v z as32
Xcmp32 n v z op[2:1] fcmp[31:0] cmp32

Waclk a[31:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
+ 0x00000000 0x55555555 0x00000000 0x55555555 0xFFFFFFFF 0x00000000 0x00000000
+ 0xAAAAAAAA 0x00000000 0xAAAAAAAA 0x00000001 0xFFFFFFFF 0x80000000 0xFFFFFFFF
+ 0x00000002 0x80000000 0x00000003 0x7FFFFFFF 0x00000003
+ 0x00000002 0x80000000 0x00000003 0x7FFFFFFF 0x00000003
+ 0x00000002 0x80000000 0x00000003 0x7FFFFFFF 0x00000003

Wbclk b[31:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
+ 0x00000000 0x00000000 0x55555555 0x55555555 0xFFFFFFFF 0x00000000 0xFFFFFFFF
+ 0x00000000 0xAAAAAAAA 0xAAAAAAAA 0xFFFFFFFF 0x00000001 0x80000000 0xFFFFFFFF
+ 0xFFFFFFFD 0x00000002 0x00000005 0xFFFFFFFE 0x00000003
+ 0xFFFFFFFD 0x00000002 0x00000005 0xFFFFFFFE 0x00000003
+ 0xFFFFFFFD 0x00000002 0x00000005 0xFFFFFFFE 0x00000003

Wopclk op[2:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
+ 000 000 000 000 000 001 001
+ 000 000 000 000 000 000 001
+ 011 011 011 011 011
+ 101 101 101 101 101
+ 111 111 111 111 111

*******************************************************************************
* Simulation Commands
*******************************************************************************
.tran 580ns
.plot a[31:0]
.plot b[31:0]
.plot op[2:0]
.plot fas[31:0]
.plot fcmp0
