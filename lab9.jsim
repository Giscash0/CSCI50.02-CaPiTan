*******************************************************************************
* LAB #9
* - Carlos, Danny II
* - Piscasio, Johannes
* - Tan, Jacob
*******************************************************************************

.include "8clocks.jsim"     
.include "nominal.jsim"     
.include "stdcell.jsim"     

*******************************************************************************
* Helper subckt to facilitate multi-bit joins.
* Used throughout to "wire together" two buses of the same width.
*******************************************************************************
.subckt join S T
  .connect S T
.ends

*******************************************************************************
* Xmemory is a 512-byte main memory containing both user instructions and data.
*   1st line = read port for the next instruction to process (inst)
*   2nd line = read port for LD instructions (memrd)
*   3rd line = write port for ST instructions (memwd, controlled by wr signal)
*   4th line = the memory statement itself (initialized from lab7.bin)
*******************************************************************************
Xmemory  vdd  0    0   pc[8:2]    inst[31:0]
+        vdd  0    0   mema[8:2]  memrd[31:0]
+        0    clk  wr  mema[8:2]  memwd[31:0]
+ $memory width=32 nlocations=128 file="lab7.bin"

*******************************************************************************
* Xregisters is a register memory device to store your Beta registers r0 - r31.
*   1st line = read port for rd1_ (addressed by ra1_)
*   2nd line = read port for rd2_ (addressed by ra2_)
*   3rd line = write port for wd (controlled by werf_ signal and address wa)
*   4th line = the memory statement itself
*   succeeding lines = initial values of the registers (all zeroed)
*******************************************************************************
Xregisters  vdd  0    0      ra1_[4:0]  rd1_[31:0]
+           vdd  0    0      ra2_[4:0]  rd2_[31:0]
+           0    clk  werf_  wa[4:0]    wd[31:0]
+ $memory width=32 nlocations=32 contents=(
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+ )

*******************************************************************************
* Register write-protection logic for R31.
* If wa == 31, we force werf_out = 0 so that r31 cannot be overwritten.
* Otherwise, werf_out follows the werf control signal.
*******************************************************************************
Xand1      wa[4:1]  is_r31a   and4      	* checks upper 4 bits of wa are 1111
Xand2      wa0      is_r31a   is_r31    and2    * combines LSB with upper bits: wa == 11111?
Xnotr31    is_r31   not_r31   inverter  	* not_r31 = 1 when wa != 31
Xwerf_calc werf     not_r31   werf_out  and2    * gate werf with not_r31

*******************************************************************************
* Xcontrol is the control ROM.
* Inputs:  z (branch condition result) + opcode[5:0]
* Output:  14 control lines packed into "control[13:0]"
*
* Layout of control bits (from MSB to LSB):
*   [ PCSEL(13:12) | RA2SEL(11) | BSEL(10) | WDSEL(9:8) |
*     ALUFN(7:2)   | Wr(1)      | WERF(0) ]
*
* For invalid / unused opcodes, we map to HALT:
*   control = 0b11000000000000
* which keeps PCSEL=11 (PC holds) and disables both memory and register writes.
*******************************************************************************
Xcontrol  vdd  0  0  z opcode[5:0]  control[13:0]
+ $memory width=14 nlocations=128 contents=(
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b00000000000001 0b01000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001301 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b01000000000001 0b00000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+ )

*******************************************************************************
* Full Adder
*
* Truth Table:
* a b c_in sum c_out
* 0 0  0    0    0
* 0 0  1    1    0
* 0 1  0    1    0
* 0 1  1    0    1
* 1 0  0    1    0
* 1 0  1    0    1
* 1 1  0    0    1
* 1 1  1    1    1
*
* sum = !a!bc_in + !ab!c_in + a!b!c_in + abc_in   from the truth table
*     = c_in(!a!b + ab) + !c_in(!ab + a!b)        by distributive law
*     = c_in!(aâb) + !c_in(aâb)                 substituting to XOR
*     = a â b â c_in                            substituting to XOR
* c_out = !abc_in + a!bc_in + ab!c_in + abc_in    from the truth table
*       = c_in(!ab + a!b) + ab(!c_in + c_in)      by distributive law
*       = c_in(!ab + a!b) + ab(1)                 by complement law
*       = c_in(!ab + a!b) + ab                    by identity law
*       = ab + c_in(aâb)                         turn to xor because we already
*                                                 know aâb from the sum
*       = !(!(ab + c_in(aâb)))                   by double negation law
*       = !(!(ab)!(c_in(aâb)))                   by De Morgan's theorem
*******************************************************************************
.subckt fa a b c_in sum c_out
  Xsum1 a b out1 xor2
	Xsum2 out1 c_in sum xor2
	Xcarry1 a b out2 nand2
	Xcarry2 c_in out1 out3 nand2
	Xcarry3 out2 out3 c_out nand2
.ends

*******************************************************************************
* 32-bit Full Adder
* We instantiate 32 full adder and the carry ripples from the less significant
* bit to the more significant bit. The ith full adder adds a_i and b_i with the
* carry input being the carry output of the previous full adder, which is
* c_out_i-1. Since the 0th fa doesn't have a previous fa, its carry input is
* cin0. Thus, each bit instantiation goes like:
*      Xbit#0 a31 b31 cout30 sum31 cout31 fa
*      Xbit#1 a30 b30 cout29 sum30 cout30 fa
*      ...
*      Xbit#30 a1 b1 cout0 sum1 cout1 fa
*      Xbit#31 a0 b0 cin0 sum0 cout0 fa
*
* However with the power of jsim, we can instantiate by:
*      Xbits 32_a 32_b 31_prev_cout_then_least_bit's_cin 32_sum 32_carry_out fa
*******************************************************************************
.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xbits a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends

*******************************************************************************
* 32-bit Adder/Subtractor
* For inputs, we have a 32-bit A and B as well as the op0. The input op0 is 0
* for addition and 1 for subtraction. We know that A - B = A + ~B + 1. We also
* know that the constructor for the 32-bit Full Adder inputs a carry in bit for
* the least significant bit. Thus, we can connect op0 to cin0 to handle the +1.
*
* For the ~B, we can just use a 2-input multiplexer where d0 = B, d1 = ~B, and
* s = op0. This is so that when op0 = 0, indicating addition, what is being added
* is just A + B(d0) + 0(op0) or A + B. Otherwise, when op0 = 1, indicating
* subtraction, what is being added is A + ~B(d1) + 1(op0) or A - B.
*
* We have output n which is 0 if fas is positive and 1 if negative. We only need
* to check fas31. The most significant bit of signed bits is 0 when it is positive
* and 1 when it is negative. Therefore, n = fas31.
* 
* Output v is 1 when the operation result in a signed overflow or the value
* "wrapped around". We notice that when the carry out of the 2 most significant
* bits are not equal, there is an overflow. If they are equal, there is no
* overflow. Putting that in a truth table, it is an exclusive or. Therefore,
* v = cout31 â cout30
*
* Output z is 1 if all 32 bits fas[31:0] are 0, otherwise z is 0.
* Suppose we want to make 2 bits return 1 if both bits are 0:
*      X = !A!B
*      X = !(A+B)
* 4 bits would be X(A,B) and X(C,D):
*      X = !(A+B)!(C+D)
*      X = !!(!(A+B)!(C+D))
* 8 bits would be X(A,B,C,D) and X(E,F,G,H):
*      X = !!(!(A+B)!(C+D)) !!(!(E+F)!(G+H))
*      X = !(!(!(A+B)!(C+D))+!(!(E+F)!(G+H)))
* 16 bits would be X(A,B,C,D,E,F,G,H) and X(I,J,K,L,M,N,O,P)
*      X = !(!(!(A+B)!(C+D))+!(!(E+F)!(G+H))) !(!(!(I+J)!(K+L))+!(!(M+N)!(O+P)))
*      X = !!(!(!(!(A+B)!(C+D))+!(!(E+F)!(G+H))) !(!(!(I+J)!(K+L))+!(!(M+N)!(O+P))))
* 32 bits would be X(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) and X(16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
*      X = !!(!(!(!(0+1)!(2+3))+!(!(4+5)!(6+7))) !(!(!(8+9)!(10+11))+!(!(12+13)!(14+15))))
*          !!(!(!(!(16+17)!(18+19))+!(!(20+21)!(22+23))) !(!(!(24+25)!(26+27))+!(!(28+29)!(30+31))))
*      X = !(
*          !(!(!(!(0+1)!(2+3))+!(!(4+5)!(6+7))) !(!(!(8+9)!(10+11))+!(!(12+13)!(14+15))))
*          +
*          !(!(!(!(16+17)!(18+19))+!(!(20+21)!(22+23))) !(!(!(24+25)!(26+27))+!(!(28+29)!(30+31))))
*          )
* This makes 16 NOR gates at the innermost, then 8 NAND gates, then 4 NOR gates,
* then 2 NAND gates, and finally a NOR gates. We arived to our answer using
* multiple De Morgan's and double negation. We substitute X to z and the numbers
* to fas[31:0].
*******************************************************************************
.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
  * nb# = ~b#
  XinvertedB b[31:0] nb[31:0] inverter
  * connect op0 to all mux
  * if op0 = 0, newb# = b#
  * else if op0 = 1, newb# = nb#
  Xbmux op0#32 b[31:0] nb[31:0] newb[31:0] mux2
  * we add a[31:0] and newb[31:0] using the 32-bit Adder with op0 as cin0
  Xas a[31:0] newb[31:0] op0 fas[31:0] cout[31:30] add32
  * since n = fas31, we connect them
  .connect fas31 n
  * we get XOR of cout31 and cout30 to get v
  Xoverflow cout[31:30] v xor2

  * in solving for z we start with the first 16 NORs
  Xza fas[31:0] fza[15:0] nor2
  * then 8 NANDs
  Xzb fza[15:0] fzb[7:0] nand2
  * then 4 NORs
  Xzc fzb[7:0] fzc[3:0] nor2
  * then 2 NANDs
  Xzd fzc[3:0] fzd[1:0] nand2
  * finally 1 NOR
  Xze fzd[1:0] z nor2
.ends

*******************************************************************************
* 32-bit Comparator
* We compare a[31:0] and b[31:0]. We have n, v, z inputs coming from the output
* of as32. op[2:1] determines the comparison type. fcmp0 is the boolean that
* affirms if the comparison is true(1) or false(0).
* We don't care when we are adding and when both op1 & op2 are 0.
*
* If op1=1 then fcmp0=1 iff A=B.
* We only care about subtraction. When subtracting using as32 and A = B,
* A - B = 0. This makes z = 1. Thus, if op1=1 then fcmp0=1 iff z=1. Therefore:
*      fcmp0 = (op1)(z)
*
* If op2=1 then fcmp0=1 iff A<B.
* We only care about subtraction. Note the following 4-bit subtraction and the
* resulting n and v values and wether A is less than B:
*      0101 - 0011: n=0 v=0 isless=0
*      1001 - 0011: n=0 v=1 isless=1
*      0011 - 0101: n=1 v=0 isless=1
*      0111 - 1101: n=1 v=1 isless=0
* We notice that isless = nâv. Therefore:
*      fcmp0 = (op2)(nâv)
*
* If both op1 and op2 are 1, then fcmp0=1 iff A<=B. This is read as less than
* OR equal to. Therefore we add the first 2:
*      fcmp0 = (op1)(z) + (op2)(nâv)
*******************************************************************************
.subckt cmp32 n v z op[2:1] fcmp[31:0]
  * we don't care about fcmp[31:1] so we connect it to ground
  .connect 0 fcmp[31:1]

  * for op1=1
  Xandop1 op1 z isequal and2
  
  * for op2=1
  Xxorop2 n v exclusive xor2
  Xandop2 op2 exclusive isless and2

  * for op1=op2=1
  Xboth isequal isless fcmp0 or2
.ends

*******************************************************************************
* 32-bit Bitwise Boolean Circuit
* 4-Way Multiplexers are essentially programmable boolean gates. Using the
* A-bit and B-bit as the selectors, the data inputs can just be the 1s and 0s
* as if it was a truth table.
*
* The subcircuit's op inputs already determines the data inputs so the only
* thing we need to instantiate are the 32 4-way multiplexers for each bit.
*
* op[3:0] = 1000 (AND)
*         = 1110 (OR)
*         = 0110 (XOR)
*******************************************************************************
.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
  Xmuxes a[31:0] b[31:0] op0#32 op1#32 op2#32 op3#32 fbool[31:0] mux4
.ends

*******************************************************************************
* 32-bit Shifter
* the inputs are: a[31:0] - value to bit-shift
*                 b[4:0]  - how many bits to shift
*                 op[1:0] - type of shift: 00-left 01-right 11-arithmetic right
*                         - op1 is 1 if arithmetic, op0 is 1 if right
*
* The logical right shift can be composed of 5 layers of 32 muxs. The select
* input of the muxes for each layer corresponds to b:
*       b4 layer shifts by 16
*       b3 layer shifts by 8
*       b2 layer shifts by 4
*       b1 layer shifts by 2
*       b0 layer shifts by 1
*
* An arithmetic right shift is just a logical right shift but instead of always
* 0, what is being shifted in is the most significant bit. This can be done
* using a single mux2 whose selector is op1.
*
* A logical left shift is just a logical right shift but reversed. This can be
* done using 64 mux2. The first 32 mux will reverse the bits before shifting
* then another 32 mux to revert back after shifting. The bit pairs to be data
* inputs of mux2 are: 31-0, 30-1, ..., 1-30, 0-31. op0 is the selector for all
* of the muxes.
*******************************************************************************
.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]
  *shift in 0s if logical and MSB if arithmetic
  Xshift_in op1 0 a31 s_in mux2

  *reverse input if left
  Xreverse op0#32 a[0:31] a[31:0] input[31:0] mux2

  *shifting by layer
  Xshift16 b4#32 input[31:0] s_in#16 input[31:16] s4out[31:0] mux2
  Xshift8 b3#32 s4out[31:0] s_in#8 s4out[31:8] s3out[31:0] mux2
  Xshift4 b2#32 s3out[31:0] s_in#4 s3out[31:4] s2out[31:0] mux2
  Xshift2 b1#32 s2out[31:0] s_in#2 s2out[31:2] s1out[31:0] mux2
  Xshift1 b0#32 s1out[31:0] s_in s1out[31:1] s0out[31:0] mux2

  *revert back if left
  Xrevert op0#32 s0out[0:31] s0out[31:0] fshift[31:0] mux2
.ends

*******************************************************************************
* 32-bit Arithmetic Logic Unit
* We instantiate all 4 functions and input a[31:0] b[31:0] alufn[3:0] to all the
* functions while noting that cmp32 relies on as32 so their nvz must be connected.
*
* alufn[5:4] determines the type of function to do:
*       00 - adder/subtractor (as32)
*       01 - boolean (bool32)
*       10 - shifter (shift32)
*       11 - comparator (cmp32)
* We use 32 4-way multiplexers with alufn[5:4] as selectors and the outputs of
* the functions as the data inputs.
*******************************************************************************
.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]
  Xas a[31:0] b[31:0] alufn0 fas[31:0] n v z as32
  Xbool a[31:0] b[31:0] alufn[3:0] fbool[31:0] bool32
  Xshift a[31:0] b[4:0] alufn[1:0] fshift[31:0] shift32
  Xcmp n v z alufn[2:1] fcmp[31:0] cmp32
  Xtype alufn4#32 alufn5#32 fas[31:0] fbool[31:0] fshift[31:0] fcmp[31:0] f[31:0] mux4
.ends

*******************************************************************************
* Control ROM output bit-to-signal wiring.
* Maps packed "control[13:0]" bits into named control signals.
*******************************************************************************
Xjcontrola control[13:12] pcsel[1:0]   join   * PCSEL controls next PC source
Xjcontrolb control11      ra2sel       join   * RA2SEL chooses between rb/rc
Xjcontrolc control10      bsel         join   * BSEL chooses between rd2_ / c
Xjcontrold control[9:8]   wdsel[1:0]   join   * WDSEL chooses WD source
Xjcontrole control[7:2]   alufn[5:0]   join   * ALUFN controls ALU function
Xjcontrolf control1       wr_temp      join   * raw memory write enable
Xjcontrolg control0       werf         join   * raw register-file write enable

*******************************************************************************
* Decode instruction fields:
*   opcode = inst[31:26]
*   rc     = inst[25:21]
*   ra     = inst[20:16]
*   rb     = inst[15:11]
*   c      = inst[15:0] (immediate / branch displacement)
*******************************************************************************
Xjinsta inst[31:26] opcode[5:0] join
Xjinstb inst[25:21] rc[4:0]     join
Xjinstc inst[20:16] ra[4:0]     join
Xjinstd inst[15:11] rb[4:0]     join
Xjinste inst[15:0]  c[15:0]     join

*******************************************************************************
* Basic datapath wiring:
* - Connect clock to an internal clk2 bus.
* - Route ra -> ra1_ (first register read address).
* - Route rc -> wa  (writeback register address).
* - Route ALU output to mema (low bits) and memwd to rd2_ for ST.
*******************************************************************************
Xclk   clk         clk2       join
Xra1_  ra[4:0]     ra1_[4:0]  join
Xwa    wa[4:0]     rc[4:0]    join
Xmema  mema[8:0]   f[8:0]     join
Xmemwd memwd[31:0] rd2_[31:0] join

*******************************************************************************
* Group some control signals together for compact plotting.
*******************************************************************************
Xjdisplaya ra2_b_wdsel[3:0] ra2sel bsel wdsel[1:0] join
Xjdisplayb wr_werfs[2:0]    wr werf werf_          join

*******************************************************************************
* Program counter storage:
*   pc[0:1]      : low bits of PC
*   pc[31:2]     : remaining upper bits
*   pcplus4      : PC + 4
*******************************************************************************
Xpc00    0#2           clk#2    pc[0:1]    dreg
Xpc8to2  pc_feed[31:2] clk#30   pc[31:2]   dreg
Xpcplus4 pc[31:0] 0#29 vdd 0#2 0 pcplus4[31:0] pcout[31:30] add32

*******************************************************************************
* Branch target computation:
*   - Sign-extend the 16-bit immediate (c) to 32 bits (c_sext).
*   - Shift left by 2 (c_shift) to form a word-aligned offset.
*   - Add to PC+4 to get BT (branch target).
*******************************************************************************
Xcbranchsext1  c15#16        c_sext[31:16] join
Xcbranchsext2  c[15:0]       c_sext[15:0]  join
Xcbranchshift1 c_sext[29:0]  c_shift[31:2] join
Xcbranchshift2 c_shift[1:0]  0#2           join
Xcbranchadd    c_shift[31:0] pcplus4[31:0] 0 bt[31:0] btout[31:30] add32

*******************************************************************************
* Jump target:
* For JMP-type instructions, we directly use rd1_ as the jump target (jt).
*******************************************************************************
Xjump rd1_[31:0] jt[31:0] join

*******************************************************************************
* Z flag generator for branches:
* Checks if rd1_ == 0 by OR-reducing its bits, then negating.
*   - rdbranch1_: first-stage NOR over 8-bit slices
*   - rdbranch2_: second-stage NAND combining partial results
*   - final NOR gives z.
*******************************************************************************
Xz1 rd1_[0:7]  rd1_[8:15] rd1_[16:23] rd1_[24:31] rdbranch1_[0:7] nor4
Xz2 rdbranch1_[0:1] rdbranch1_[2:3] rdbranch1_[4:5] rdbranch1_[6:7] rdbranch2_[0:1] nand4 
Xz3 rdbranch2_0 rdbranch2_1 z nor2

*******************************************************************************
* PCSEL, RA2SEL, BSEL, WDSEL multiplexers:
* PCSEL  chooses next PC among {PC+4, BT, JT, PC}
* RA2SEL chooses second register address (rb or rc)
* BSEL 	 chooses ALU B input (rd2_ or sign-extended/immediate)
* WDSEL  chooses WD source (PC+4, ALU result, memory data, or 0)
*******************************************************************************
Xpcselmux  pcsel0#32 pcsel1#32  pcplus4[31:0]  bt[31:0]
+          jt[31:0]  pc[31:0]   next_pc[31:0]  mux4

Xra2selmux ra2sel#5  rb[4:0]    rc[4:0]        ra2_[4:0] mux2

Xbselmux   bsel#32   rd2_[31:0] c15#16 c[15:0] b[31:0] mux2

Xwdselmux  wdsel0#32 wdsel1#32  pcplus4[31:0]  f[31:0]
+          memrd[31:0] 0#32 wd[31:0] mux4

*******************************************************************************
* Reset waveform:
* Wreset produces a short initial pulse on "reset" to initialize PC and control.
*******************************************************************************
Wreset reset nrz(0,5,10ns,.1ns,.1ns,0.1ns) 1 0 

*******************************************************************************
* Reset gating:
* - On reset, PC is forced to 0 via reset mux.
* - werf_ and wr are forced low during reset, then follow werf_out / wr_temp.
*******************************************************************************
XresetPC   reset#32 next_pc[31:0] 0#32     pc_feed[31:0] mux2
XresetWerf reset    werf_out      0        werf_         mux2
XresetWr   reset    wr_temp       0        wr            mux2

*******************************************************************************
* ALU instance:
*   Inputs:
*     rd1_ : first operand (A)
*     b    : second operand (B, chosen by BSEL)
*     alufn: function selector from control ROM
*   Output:
*     f    : ALU result (goes to mema, wdsel mux, etc.)
*******************************************************************************
Xalu rd1_[31:0] b[31:0] alufn[5:0] f[31:0] alu32

*******************************************************************************
* Simulation setup and waveform plots.
* We simulate 1430 ns and plot:
*   - pc: program counter
*   - betaop: decoded operation mnemonic from opcode
*   - ra, rb, rc: register indices
*   - c: immediate / branch displacement
*   - control signals (pcsel, ra2sel, bsel, wdsel, alufn, wr, werf, werf_)
*   - rd1_, rd2_, wd: register file data paths
*   - mema, memrd, memwd: memory address/data paths
*******************************************************************************
.tran 1430ns
.plot pc[8:0]
.plot betaop(opcode[5:0])
.plot d(ra[4:0])
.plot d(rb[4:0])
.plot d(rc[4:0])
.plot sd(c[15:0])
.plot b(pcsel[1:0])
.plot b(ra2_b_wdsel[3:0])
.plot b(alufn[5:0])
.plot b(wr_werfs[2:0])
.plot sd(rd1_[31:0])
.plot sd(rd2_[31:0])
.plot sd(wd[31:0])
.plot d(mema[8:0])
.plot sd(memrd[31:0])
.plot sd(memwd[31:0])
